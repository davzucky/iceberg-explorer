{% extends "base.html" %}

{% block title %}Query - Iceberg Explorer{% endblock %}

{% block nav_query %}bg-iceberg-800 text-white{% endblock %}

{% block head %}
<!-- Monaco Editor loader -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
<style>
    #editor-container {
        height: 200px;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
    }
    .results-table-container {
        max-height: 500px;
        overflow: auto;
    }
    .results-table th {
        position: sticky;
        top: 0;
        background: white;
        z-index: 10;
    }
    .filter-row th {
        position: sticky;
        top: 36px;
        background: #f9fafb;
        z-index: 9;
    }
    .sort-icon {
        opacity: 0.3;
        transition: opacity 0.2s;
    }
    .sort-icon.active {
        opacity: 1;
    }
</style>
{% endblock %}

{% block sidebar %}
<div
    hx-get="/ui/partials/namespace-tree"
    hx-trigger="load"
    hx-swap="innerHTML"
>
    <div class="flex items-center justify-center py-8">
        <svg class="animate-spin h-6 w-6 text-iceberg-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
    </div>
</div>
{% endblock %}

{% block content %}
<div x-data="queryEditor()" x-init="initEditor()" class="space-y-4">
    <!-- Query editor -->
    <div class="rounded-lg bg-white p-6 shadow">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-semibold text-gray-900">SQL Query Editor</h2>
            <div class="flex items-center space-x-3">
                <!-- Timeout selector -->
                <div class="flex items-center space-x-2">
                    <label for="timeout" class="text-sm text-gray-600">Timeout:</label>
                    <select
                        id="timeout"
                        x-model="timeout"
                        class="rounded-md border-gray-300 text-sm shadow-sm focus:border-iceberg-500 focus:ring-iceberg-500"
                        :disabled="isExecuting"
                    >
                        <option value="30">30s</option>
                        <option value="60">60s</option>
                        <option value="300" selected>5m</option>
                        <option value="900">15m</option>
                        <option value="3600">1h</option>
                    </select>
                </div>

                <!-- Cancel button (visible during execution) -->
                <button
                    x-show="isExecuting"
                    x-cloak
                    @click="cancelQuery()"
                    class="inline-flex items-center rounded-md bg-red-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-red-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-600"
                >
                    <svg class="mr-1.5 h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                    Cancel
                </button>

                <!-- Run button -->
                <button
                    @click="executeQuery()"
                    :disabled="isExecuting || !sql.trim()"
                    class="inline-flex items-center rounded-md bg-iceberg-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-iceberg-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-iceberg-600 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <template x-if="isExecuting">
                        <svg class="animate-spin mr-1.5 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </template>
                    <template x-if="!isExecuting">
                        <svg class="mr-1.5 h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" />
                        </svg>
                    </template>
                    <span x-text="isExecuting ? 'Running...' : 'Run Query'"></span>
                </button>
            </div>
        </div>

        <!-- Monaco editor container -->
        <div id="editor-container"></div>

        <!-- Error message display -->
        <div x-show="error" x-cloak class="mt-4">
            <div class="rounded-md bg-red-50 p-4">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium text-red-800">Query Error</h3>
                        <div class="mt-2 text-sm text-red-700">
                            <p x-text="error"></p>
                        </div>
                    </div>
                    <div class="ml-auto pl-3">
                        <button @click="error = null" class="inline-flex rounded-md bg-red-50 p-1.5 text-red-500 hover:bg-red-100">
                            <span class="sr-only">Dismiss</span>
                            <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status display during execution -->
        <div x-show="status && isExecuting" x-cloak class="mt-4">
            <div class="rounded-md bg-blue-50 p-4">
                <div class="flex items-center">
                    <svg class="animate-spin h-5 w-5 text-blue-400 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p class="text-sm text-blue-700">Status: <span x-text="status" class="font-medium"></span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Results section -->
    <div class="rounded-lg bg-white p-6 shadow">
        <!-- Results header -->
        <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-4">
                <h2 class="text-lg font-semibold text-gray-900">Results</h2>
                <!-- Export CSV button -->
                <button
                    x-show="columns.length > 0 && queryId"
                    x-cloak
                    @click="exportCSV()"
                    :disabled="isExporting || isExecuting || isStreaming"
                    class="inline-flex items-center rounded-md bg-white px-3 py-1.5 text-sm font-medium text-gray-700 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <template x-if="isExporting">
                        <svg class="animate-spin mr-1.5 h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </template>
                    <template x-if="!isExporting">
                        <svg class="mr-1.5 h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                        </svg>
                    </template>
                    <span x-text="isExporting ? 'Exporting...' : 'Export CSV'"></span>
                </button>
            </div>
            <!-- Pagination controls -->
            <div x-show="columns.length > 0" class="flex items-center space-x-4">
                <!-- Page size selector -->
                <div class="flex items-center space-x-2">
                    <label for="pageSize" class="text-sm text-gray-600">Page size:</label>
                    <select
                        id="pageSize"
                        x-model="pageSize"
                        @change="changePageSize()"
                        class="rounded-md border-gray-300 text-sm shadow-sm focus:border-iceberg-500 focus:ring-iceberg-500"
                        :disabled="isStreaming"
                    >
                        <option value="100">100</option>
                        <option value="250">250</option>
                        <option value="500">500</option>
                        <option value="1000">1000</option>
                    </select>
                </div>
                <!-- Page navigation -->
                <div class="flex items-center space-x-2">
                    <button
                        @click="prevPage()"
                        :disabled="currentPage <= 1 || isStreaming"
                        class="inline-flex items-center rounded-md bg-white px-2 py-1 text-sm font-medium text-gray-700 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                        </svg>
                    </button>
                    <span class="text-sm text-gray-600">
                        Page <span x-text="currentPage" class="font-medium"></span> of <span x-text="totalPages" class="font-medium"></span>
                    </span>
                    <button
                        @click="nextPage()"
                        :disabled="currentPage >= totalPages || isStreaming"
                        class="inline-flex items-center rounded-md bg-white px-2 py-1 text-sm font-medium text-gray-700 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Streaming indicator -->
        <div x-show="isStreaming" x-cloak class="mb-4">
            <div class="rounded-md bg-blue-50 p-3">
                <div class="flex items-center">
                    <svg class="animate-spin h-4 w-4 text-blue-400 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p class="text-sm text-blue-700">
                        Streaming results... <span x-text="streamedRows" class="font-medium"></span> rows received
                    </p>
                </div>
            </div>
        </div>

        <!-- Results summary -->
        <div x-show="resultSummary && !isStreaming" x-cloak class="mb-4">
            <div class="flex items-center justify-between text-sm text-gray-600">
                <p>
                    Query completed in <span x-text="resultSummary?.duration" class="font-medium"></span>s
                </p>
                <p>
                    <span x-text="resultSummary?.rowCount" class="font-medium"></span> rows returned
                    <template x-if="filteredRows.length !== allRows.length">
                        <span> (<span x-text="filteredRows.length" class="font-medium"></span> shown after filtering)</span>
                    </template>
                </p>
            </div>
        </div>

        <!-- Results table or empty state -->
        <div id="query-results">
            <!-- Empty state -->
            <template x-if="columns.length === 0 && !isExecuting && !isStreaming">
                <div class="rounded-lg border border-dashed border-gray-300 p-8 text-center">
                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    <p class="mt-2 text-sm text-gray-500">Run a query to see results</p>
                </div>
            </template>

            <!-- Results table -->
            <template x-if="columns.length > 0">
                <div class="results-table-container border border-gray-200 rounded-lg">
                    <table class="results-table min-w-full divide-y divide-gray-200">
                        <!-- Header row with sortable columns -->
                        <thead>
                            <tr>
                                <template x-for="(col, colIndex) in columns" :key="colIndex">
                                    <th
                                        @click="toggleSort(colIndex)"
                                        class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-50 select-none"
                                    >
                                        <div class="flex items-center space-x-1">
                                            <span x-text="col.name"></span>
                                            <span class="flex flex-col">
                                                <svg
                                                    class="h-3 w-3 sort-icon"
                                                    :class="{'active': sortColumn === colIndex && sortDirection === 'asc'}"
                                                    fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
                                                >
                                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                                                </svg>
                                                <svg
                                                    class="h-3 w-3 -mt-1 sort-icon"
                                                    :class="{'active': sortColumn === colIndex && sortDirection === 'desc'}"
                                                    fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
                                                >
                                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                                                </svg>
                                            </span>
                                        </div>
                                    </th>
                                </template>
                            </tr>
                            <!-- Filter row -->
                            <tr class="filter-row">
                                <template x-for="(col, colIndex) in columns" :key="'filter-' + colIndex">
                                    <th class="px-3 py-1">
                                        <input
                                            type="text"
                                            :placeholder="'Filter ' + col.name"
                                            x-model="columnFilters[colIndex]"
                                            @input="applyFilters()"
                                            class="w-full text-xs rounded border-gray-300 px-2 py-1 focus:border-iceberg-500 focus:ring-iceberg-500"
                                        />
                                    </th>
                                </template>
                            </tr>
                        </thead>
                        <!-- Data rows -->
                        <tbody class="bg-white divide-y divide-gray-200">
                            <template x-for="(row, rowIndex) in paginatedRows" :key="rowIndex">
                                <tr class="hover:bg-gray-50">
                                    <template x-for="(cell, cellIndex) in row" :key="cellIndex">
                                        <td class="px-3 py-2 text-sm text-gray-900 whitespace-nowrap max-w-xs truncate" :title="formatCell(cell)">
                                            <span x-text="formatCell(cell)"></span>
                                        </td>
                                    </template>
                                </tr>
                            </template>
                            <!-- No results after filtering -->
                            <template x-if="filteredRows.length === 0 && allRows.length > 0">
                                <tr>
                                    <td :colspan="columns.length" class="px-3 py-8 text-center text-sm text-gray-500">
                                        No rows match the current filters
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </template>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function queryEditor() {
    return {
        editor: null,
        sql: '',
        timeout: 300,
        isExecuting: false,
        isStreaming: false,
        isExporting: false,
        queryId: null,
        error: null,
        status: null,
        resultSummary: null,
        pollInterval: null,

        // Results data
        columns: [],
        allRows: [],
        filteredRows: [],
        streamedRows: 0,

        // Sorting
        sortColumn: null,
        sortDirection: 'asc',

        // Filtering
        columnFilters: [],

        // Pagination
        pageSize: 100,
        currentPage: 1,

        get totalPages() {
            return Math.max(1, Math.ceil(this.filteredRows.length / this.pageSize));
        },

        get paginatedRows() {
            const start = (this.currentPage - 1) * this.pageSize;
            const end = start + this.pageSize;
            return this.filteredRows.slice(start, end);
        },

        initEditor() {
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
            require(['vs/editor/editor.main'], () => {
                this.editor = monaco.editor.create(document.getElementById('editor-container'), {
                    value: '-- Enter your SQL query here\nSELECT * FROM ',
                    language: 'sql',
                    theme: 'vs',
                    minimap: { enabled: false },
                    automaticLayout: true,
                    fontSize: 14,
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    tabSize: 2,
                });

                this.editor.onDidChangeModelContent(() => {
                    this.sql = this.editor.getValue();
                });

                this.sql = this.editor.getValue();

                // Ctrl/Cmd + Enter to run query
                this.editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
                    if (!this.isExecuting && this.sql.trim()) {
                        this.executeQuery();
                    }
                });
            });
        },

        resetResults() {
            this.columns = [];
            this.allRows = [];
            this.filteredRows = [];
            this.columnFilters = [];
            this.sortColumn = null;
            this.sortDirection = 'asc';
            this.currentPage = 1;
            this.streamedRows = 0;
            this.resultSummary = null;
        },

        async executeQuery() {
            if (this.isExecuting || !this.sql.trim()) return;

            this.isExecuting = true;
            this.error = null;
            this.status = 'pending';
            this.queryId = null;
            this.resetResults();

            try {
                const response = await fetch('/api/v1/query/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sql: this.sql,
                        timeout: parseInt(this.timeout)
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    this.error = data.detail || 'Failed to execute query';
                    this.isExecuting = false;
                    this.status = null;
                    return;
                }

                this.queryId = data.query_id;
                this.status = data.status;

                // Poll for status if not completed
                if (data.status !== 'completed') {
                    this.startStatusPolling();
                } else {
                    await this.fetchResults();
                }

            } catch (err) {
                this.error = err.message || 'Network error';
                this.isExecuting = false;
                this.status = null;
            }
        },

        startStatusPolling() {
            this.pollInterval = setInterval(async () => {
                if (!this.queryId) {
                    this.stopStatusPolling();
                    return;
                }

                try {
                    const response = await fetch(`/api/v1/query/${this.queryId}/status`);
                    const data = await response.json();

                    if (!response.ok) {
                        this.error = data.detail || 'Failed to check status';
                        this.stopStatusPolling();
                        this.isExecuting = false;
                        return;
                    }

                    this.status = data.status;

                    if (data.status === 'completed') {
                        this.stopStatusPolling();
                        await this.fetchResults();
                    } else if (data.status === 'failed') {
                        this.stopStatusPolling();
                        this.error = data.error_message || 'Query failed';
                        this.isExecuting = false;
                    } else if (data.status === 'cancelled') {
                        this.stopStatusPolling();
                        this.error = 'Query was cancelled';
                        this.isExecuting = false;
                    }

                } catch (err) {
                    this.error = err.message || 'Failed to check status';
                    this.stopStatusPolling();
                    this.isExecuting = false;
                }
            }, 500);
        },

        stopStatusPolling() {
            if (this.pollInterval) {
                clearInterval(this.pollInterval);
                this.pollInterval = null;
            }
        },

        async fetchResults() {
            if (!this.queryId) return;

            this.isStreaming = true;
            this.streamedRows = 0;

            try {
                const response = await fetch(`/api/v1/query/${this.queryId}/results?page_size=1000`);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                let buffer = '';
                let metadata = null;
                let complete = null;
                const allRows = [];

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (!line.trim()) continue;
                        try {
                            const msg = JSON.parse(line);
                            if (msg.type === 'metadata') {
                                metadata = msg;
                                this.columns = msg.columns;
                                this.columnFilters = new Array(msg.columns.length).fill('');
                            } else if (msg.type === 'data') {
                                allRows.push(...msg.rows);
                                this.streamedRows = allRows.length;
                            } else if (msg.type === 'complete') {
                                complete = msg;
                            } else if (msg.type === 'error') {
                                this.error = msg.error;
                            }
                        } catch (e) {
                            console.warn('Failed to parse result line:', line);
                        }
                    }
                }

                this.allRows = allRows;
                this.filteredRows = [...allRows];

                if (complete) {
                    this.resultSummary = {
                        rowCount: complete.rows_returned,
                        duration: complete.duration_seconds.toFixed(3)
                    };
                    if (metadata) {
                        this.resultSummary.totalRows = metadata.total_rows;
                    }
                }

            } catch (err) {
                this.error = err.message || 'Failed to fetch results';
            } finally {
                this.isExecuting = false;
                this.isStreaming = false;
                this.status = null;
            }
        },

        async cancelQuery() {
            if (!this.queryId) return;

            try {
                const response = await fetch(`/api/v1/query/${this.queryId}/cancel`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (!response.ok) {
                    this.error = data.detail || 'Failed to cancel query';
                    return;
                }

                this.stopStatusPolling();
                this.status = data.status;

                if (data.cancelled) {
                    this.error = 'Query cancelled';
                }

            } catch (err) {
                this.error = err.message || 'Failed to cancel query';
            } finally {
                this.isExecuting = false;
                this.isStreaming = false;
            }
        },

        toggleSort(colIndex) {
            if (this.sortColumn === colIndex) {
                if (this.sortDirection === 'asc') {
                    this.sortDirection = 'desc';
                } else {
                    // Third click removes sorting
                    this.sortColumn = null;
                    this.sortDirection = 'asc';
                    this.applyFilters();
                    return;
                }
            } else {
                this.sortColumn = colIndex;
                this.sortDirection = 'asc';
            }
            this.applySort();
        },

        applySort() {
            if (this.sortColumn === null) return;

            const colIndex = this.sortColumn;
            const direction = this.sortDirection === 'asc' ? 1 : -1;

            this.filteredRows.sort((a, b) => {
                const valA = a[colIndex];
                const valB = b[colIndex];

                // Handle nulls
                if (valA === null && valB === null) return 0;
                if (valA === null) return direction;
                if (valB === null) return -direction;

                // Compare based on type
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return (valA - valB) * direction;
                }

                // String comparison for everything else
                const strA = String(valA).toLowerCase();
                const strB = String(valB).toLowerCase();
                return strA.localeCompare(strB) * direction;
            });

            this.currentPage = 1;
        },

        applyFilters() {
            this.filteredRows = this.allRows.filter(row => {
                return this.columnFilters.every((filter, colIndex) => {
                    if (!filter.trim()) return true;

                    const cellValue = row[colIndex];
                    if (cellValue === null || cellValue === undefined) {
                        return filter.toLowerCase() === 'null';
                    }

                    const filterLower = filter.toLowerCase();
                    const cellStr = String(cellValue).toLowerCase();

                    // Check for numeric range filters (e.g., ">100", "<50", ">=10", "<=20")
                    if (typeof cellValue === 'number') {
                        const rangeMatch = filter.match(/^([<>]=?)\s*(-?\d+\.?\d*)$/);
                        if (rangeMatch) {
                            const op = rangeMatch[1];
                            const num = parseFloat(rangeMatch[2]);
                            switch (op) {
                                case '>': return cellValue > num;
                                case '<': return cellValue < num;
                                case '>=': return cellValue >= num;
                                case '<=': return cellValue <= num;
                            }
                        }
                    }

                    // Default text contains filter
                    return cellStr.includes(filterLower);
                });
            });

            // Reapply sort if active
            if (this.sortColumn !== null) {
                this.applySort();
            }

            this.currentPage = 1;
        },

        formatCell(value) {
            if (value === null || value === undefined) {
                return 'NULL';
            }
            if (typeof value === 'boolean') {
                return value ? 'true' : 'false';
            }
            if (typeof value === 'object') {
                return JSON.stringify(value);
            }
            return String(value);
        },

        prevPage() {
            if (this.currentPage > 1) {
                this.currentPage--;
            }
        },

        nextPage() {
            if (this.currentPage < this.totalPages) {
                this.currentPage++;
            }
        },

        changePageSize() {
            this.currentPage = 1;
        },

        async exportCSV() {
            if (!this.queryId || this.isExporting) return;

            this.isExporting = true;
            this.error = null;

            try {
                const response = await fetch('/api/v1/export/csv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query_id: this.queryId
                    })
                });

                if (!response.ok) {
                    const data = await response.json();
                    this.error = data.detail || 'Failed to export CSV';
                    return;
                }

                // Get filename from Content-Disposition header
                const disposition = response.headers.get('Content-Disposition');
                let filename = 'export.csv';
                if (disposition) {
                    const match = disposition.match(/filename="?([^"]+)"?/);
                    if (match) {
                        filename = match[1];
                    }
                }

                // Download the file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

            } catch (err) {
                this.error = err.message || 'Failed to export CSV';
            } finally {
                this.isExporting = false;
            }
        }
    };
}
</script>
{% endblock %}
